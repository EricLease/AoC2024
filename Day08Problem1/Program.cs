using System.Drawing;
using Utilities;

/* 
 Day 8: Resonant Collinearity ---

Ex. Input:
............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............

# - indicates an antinode created by two corresponding nodes

Antinodes occur at (p1 - d) and (p2 + d), where d = p2 - p1, a vector (x,y)
..........
...#......
..........
....a.....
..........
.....a....
..........
......#...
..........
..........

Antinodes can overlap antennas of different frequenceies, and antennas of diff frequencies don't create antinodes
..........
...#......
#.........
....a.....
........a.
.....a....
..#.......
......A...
..........
..........

The first example has antennas with two different frequencies, so the antinodes they create look like this, plus an antinode overlapping the topmost A-frequency antenna:

......#....#
...#....0...
....#0....#.
..#....0....
....0....#..
.#....@.....
...#........
#......#....
........A...
.........A..
..........#.
..........#.
There are 14 total unique locations that contain an antinode within the bounds of the map.  
NOTE: '@' is A antenna overlapping with 0 antinode

Given any input, find the number of unique antinode locations within the bounds of the map.
*/

// Algorithm:
// Parse data, create list of PointLetter
// Find all pairs of points with the same letter
// Init new antinode set ([Hash]Set of Points)
// -> Foreach:
//    calculate distance d = (p2.x - p1.x, p2.y - p1.y)
//    add to antinode set coordinates:
//      - p1 - d; 
//      - p2 + d
//      [if >= (0, 0) && < (width, height)]
// Return length of antinode set

// Expect 14
//const string _puzzleInput =
//    """
//    ............
//    ........0...
//    .....0......
//    .......0....
//    ....0.......
//    ......A.....
//    ............
//    ............
//    ........A...
//    .........A..
//    ............
//    ............
//    """;

const string _puzzleInput =
    """
    .......................O......T.....d......M......
    ..............................F...................
    ..........V..................R....................
    ............B..t..........T..........d............
    .....................B.........T................M.
    ..V.................................2.......M.....
    .......V........................F.O..........2....
    ...................................T..............
    ..................................................
    ......r..........B......................c.........
    .....o3.B.............................2...........
    ..................1...m..o....d..c.....M..........
    ......Qr....o............F....0............1......
    ....Q.......................0....................2
    ......t..........0................................
    .............R.................................mL.
    ....r..............3.....................c..1.....
    .........Q.........................1..............
    ................x...R.............................
    ...x........8.R...................................
    ..................8...............................
    ........x.u.................Z.....................
    ...........................X...............d......
    ....................30.....................f......
    ......q...............v...................c.......
    ..........t8.........D.3..........................
    .......t.......4.............8....................
    ...b..................C...........D...............
    .........................v..ND4..........K........
    .......F.........u...........C..............fZ....
    ........X..9...........N.........Z..........k.....
    .............X.6...q..........................k...
    ..............................C.Z...........m....k
    ...................4.v..............N.............
    ....................u.......D..............m......
    ............................vl.....UK.............
    ............................l..6.......f..........
    ..................q.4............N................
    ..........b....x..............fu..................
    .9..................................U.......l.....
    ....w......b.........L......6.....z.5.............
    ..........X..........W6........5............z.....
    ...........q..........L............z........n...W.
    ............................5.........n...W..z....
    ........9........w................7....n..........
    ............w......................7...K.....n....
    .........................U....K......W............
    .........w.....L.................k....7...........
    ...................7.............l.............5..
    ..............9...................................
    """;

const string AntennaeIcons = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

// Parse data, create list of PointLetter
var lines = _puzzleInput.GetLines() ?? [];
var height = lines.Count;
var width = lines?[0].Length ?? 0;
var pointLetters = new Dictionary<char, HashSet<Point>>();

for (var row = 0; row < height; row++)
{
    var line = lines![row];

    for (var col = 0; col < width; col++)
    {
        var c = line[col];
        var idx = AntennaeIcons.IndexOf(c);

        if (idx < 0) continue;

        var point = new Point(col, row);

        if (pointLetters.TryGetValue(c, out var ps)) ps.Add(point);
        else pointLetters.Add(c, [point]);
    }
}

// Find all pairs of points with the same letter (n choose k)
// - calculate distance, subtract from p1, add to p2
// - add resulting points to antinodeSet
var antinodeSet = new HashSet<Point>();

foreach (var (_, points) in pointLetters.Where(kvp => kvp.Value.Count > 1))
{
    for (var i = 0; i < points.Count - 1; i++)
    {
        var a = points.ElementAt(i);

        for (var j = i + 1; j < points.Count; j++)
        {
            var b = points.ElementAt(j);
            var d = new Point(b.X - a.X, b.Y - a.Y);

            var antiA = new Point(a.X - d.X, a.Y - d.Y);
            var antiB = new Point(b.X + d.X, b.Y + d.Y);

            if (antiA.InBounds(width, height)) antinodeSet.Add(antiA);
            if (antiB.InBounds(width, height)) antinodeSet.Add(antiB);
        }
    }
}

Console.WriteLine(antinodeSet.Count);